
\section{General ideas}

Let's take two minutes to ponder on what is absolutely necessary to make our data structure concurrent\index{Concurrent}. When we insert an element, we must start by looking for the lowest node in the tree where the difference is made, where the common prefix starts to diverge between the element we want to add and all those already inserted. First, update all parent nodes as long as necessary in order to always keep the minimum and maximum value of the entire subtree, a way to access the predecessor or successor in a constant time. Second, insert all nodes that will form the path to the leaf with the increasing prefix. Finally, it remains to insert the element at leaf level and update its direct predecessor and successor.

In the remainder of this chapter, we will consider essentially bulk operations, we will concentrate first on a set of the same operations carried out simultaneously and not a mixture of these. That is to say, we will later be interested in reading, inserting and deleting operations that will take place simultaneously, interleaved.

As a preamble, we will point out that reading / writing in the different levels of the tree cannot be done simultaneously, a certain latitude is allowed due to the different positions at which an element can be located in a hash table\index{Hash table}, hence a variable time to retrieve it. This is probably the most annoying aspect of proving that the invariants are well respected.

Look for the lowest level in the tree shouldn't be a problem. Indeed, this step is limited to the membership property and it is very likely that the previous elements are fully inserted in the tree. The only embarrassing case is when levels have not yet been inserted or are currently being inserted and only a subset of them can be determined to exist. Only, this one has a reduced impact, since we only look where the split occurs. But we must keep in mind that we can insert several elements belonging to the same subtree at the same time, or more specifically, several times the same element.

Updating parents should not be too difficult, either we practice a consistent reading policy on hash tables\index{Hash table}, that is, we can only read inserted elements, in this case, we are certain that parents exist and it is enough to update the minimum and maximum values of their subtree atomically\index{Atomic}. Either, when we read information in the hash table\index{Hash table}, we pass directly those being inserted and we do not wait for them to obtain their final value. This case can be more annoying since we can have a subset of the parent elements, we must then complete those missing or wait until they have a final value to update them.

Completing the subtree to mark the path to the leaves is not a problem as long as a special policy is put in place in the hash tables\index{Hash table}. The most attentive will have noticed the previous paragraph had the same defect and was subtly erroneous. We have completed the hash table we use to insert a new feature that is found in various implementations and is usually called \textit{upsert} (compound word for ``insert or update''). This consists simply in carrying out the same treatment as the insertion with the exception if the element is already present; in this case, a function is applied on the basis of the old and the new value and the result is written. The insertion is thus a particular case of this operation which consists only in writing the new value and discarding the old one.

The real difficulty arises when you want to insert an element at leaf level. Indeed, the operation is not limited to a simple insertion since we must update the predecessor and the successor in order to keep a coherence in the equivalent of this double linked and ordered list. This operation is far from being trivial and requires careful attention to the invariants that one wishes to keep at all times. A simple solution is to use the non-blocking\index{Lock-free} technique of the philosophers' dinner, \textit{compare and swap}\index{Compare and swap}\index{Atomic} as long as we have not blocked our two neighbors and update this information~\cite{tanenbaum2009modern}. However, this is not enough because a precedent or successor may have been inserted in the meantime, so care must be taken to keep the smallest interval and block only those. In our case, we considered a slightly different solution where we tried to define ourselves as the predecessor and successor thanks to the ``compare and swap''\index{Compare and swap} instruction.
