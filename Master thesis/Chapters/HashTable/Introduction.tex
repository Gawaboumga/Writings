
\chapter{Hash Table\index{Hash table}}\label{Hash table}

In this chapter, we will return to the primitive components of our data structure that are hash tables\index{Hash table}. We will come back to the different possible implementations and will try to compare them in the concurrent\index{Concurrent} framework. This will allow us to define a hash table\index{Hash table} that can be used as a base block in our X-fast trie\index{X-fast trie} to test parallelism capabilities for our data structure. We will focus mainly on insertion and search capabilities based on a single thread since this kind of operations will be the most useful to us.

\section{General context}

Hash tables\index{Hash table} play an important role in many algorithms and data structures. It is a fundamental data structure which can be used at many places. They can be seen as a bunch of slots where elements will be stored and every possible item from the universe will be mapped to one of the slots thanks to a hash function. Nevertheless, there can be collisions since the number of available slots is very much smaller than the size of the universe and thus each location can have multiple items mapped to them. Classical techniques of collision resolution must be adapted to GPUs\index{Graphics cards} due to their nature highly parallel:

\begin{itemize}
    \item Serialization: of the operations, indeed we cannot use locking mechanism on GPU\index{Graphics cards} and we must thus find solution without those and with the help of atomic\index{Atomic} operations. Those algorithms and data structures are often qualified as \textit{lock-free} if it guarantees system-wide progress or \textit{wait-free} if it also per-thread progress.
    \item Memory accesses: threads are intended to be used together to benefit from coalesced memory but the inherent nature of hash table\index{Hash table} makes it hard since the elements are randomly spread.
    \item Probing\index{Probing}: another big aspect is the warp notion, all the threads will have to wait for the slowest one, hence the worst-case number of probes required.\\
\end{itemize}

This structure is characterized by a memory-intensive task linked to the presence of numerous random accesses and, as GPUs\index{Graphics cards} present a very interesting memory bandwidth, it makes them good candidates for such structures. The goal is then to make the most of the parallelism offered, either through a data parallelism between the threads, or a work as little divergent as possible between all the elements of the same warp. These parallelism elements can also be used to simplify probing\index{Probing} by performing all accesses related to the following probes in one treatment. Finally, it is also interesting to reduce the number of atomic\index{Atomic} operations that are carried out. These induce a not insignificant cost when there are so numerous but they are also the only primitives ensuring the validity of the accesses on GPU\index{Graphics cards}.

There exist several ways to construct those data structures:

\begin{itemize}
    \item Perfect Hashing\index{Perfect hashing}: The best way to handle $O(1)$ operations and not to have troubles with collisions is to avoid collisions thanks to perfect hashing\index{Perfect hashing}. M. L. Fredman, J. Komlós and E. Szemerédi~\cite{fredman1984storing} introduced a simple construction at the price of space efficiency $O(N^{2})$. The problem consists essentially to find a hash function that will not cause collisions. There are $\binom{N}{2}$ pairs who can collide each with probability $N^{2}$, hence there is $\binom{N}{2} / N^{2} < \frac{1}{2}$ chance that there is a potential collision. Otherwise the other idea is to do a perfect hashing\index{Perfect hashing} on $O(N)$ elements and do the same thing on collisions (combining with the chaining\index{Chaining} idea), this allows to make it dynamic~\cite{dietzfelbinger1994dynamic}.
    \item Open Addressing\index{Open addressing}: A simple technique to implement, in order to insert an item, a series of probes is performed until an empty slot is found. There are three common strategies to probe: linear, quadratic and double hashing. Those probes must set the value atomically\index{Atomic} if it the key is empty, care must be taken with deletion. Problems also appear when the load factor is too important and the variance on the queries can be quite large. Resizing the table is also not trivial due to the expected lazy initialization of the new table~\cite{gao2005lock}. The expected number of probes is bounded by $1/(1 - \frac{N}{m})$ due to the hypergeometric probability where $m$ is the number of slots in total.
    \item Chaining\index{Chaining}: An alternative is to use a set of buckets and add elements in a linked-list fashion. But traversing pointers is generally not efficient. This approach can be completed by grouping the elements into larger packets~\cite{ashkiani2017dynamic} but variance can still be high if there are not enough buckets. Nevertheless, the possibilities of lock-free algorithms are numerous and they also guarantee the validity of iterators combined with resource management (garbage collector). The expected work is in $O(1 + \frac{N}{m})$ where $m$ is the number of buckets/chains. On average, for all the insertions, we get: $\frac{1}{N} \sum_{i=0}^{N-1} (1 + \frac{i}{m}) = O(1 + \frac{N}{m})$
    \item Cuckoo\index{Cuckoo hashing}: it ensures a small number of probes by limiting the number of slots an item can reside. The idea is that the elements are exchanged from one table to another each time a collision occurs. However, we may need to reconstruct the table entirely. There are some technical difficulties to implement those but they present fair results~\cite{alcantara2009real}. It is possible to show that if the load factor is less than $\frac{1}{2}$, the expected number of evictions is constant and the longest path is bounded by $O(\log N)$. Beyond, cycles may appear and there are specific solutions to solve those issues.
\end{itemize}

\input{Chapters/HashTable/Implementation}

\input{Chapters/HashTable/Experiments}